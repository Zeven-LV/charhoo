## 介绍


## 创建型（5种）
* 单例模式

* 抽象工厂

* 工厂方法

* 建造者模式

* 原型模式

## 结构型（7种）
* 组合模式

* 外观模式

* 代理模式

* 适配器模式

* 装饰模式

* 桥模式

* 享元模式

## 行为型（11种）
* 迭代器模式(Iterator)
    - 提供一种方法顺序访问聚合对象中各个元素而又无需暴露该对象的内部表示。
    - 使用场景：需要遍历聚合类，如Java集合框架
    - 说明：大部分的开发语言队集合都有封装，直接使用其实现即可，无需另外设计开发
    - 注意：常见不常用
* 观察者模式(Observer)
    - 定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新
    - 核心概念：观察者，被观察者，通知，接收到通知的操作
    - 使用场景：多用于实现订阅功能的场景
    - 说明：JDK中提供的接口java.util.Observable，java.util.Observer；spring中的事件驱动模型
    - 注意：常见常用
* 模板方法(Template Method)
    - 父类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。
    - 使用场景：如HttpServlet.service()
    - 说明：JUC中AQS中的引用，spring中很多的扩展都是通过模板方法实现的，如refresh，JDBCTemplate,hibernateTemplate，在spring的许多应用中还使用了回调函数，更加简洁
    - 注意：常见常用
* 命令模式(Command)
    - 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，已经支持可撤销的操作
    - 特点： 高内聚
    - 核心概念：接收者，命令，调用者
    - 使用场景：
    - 说明：JDBCTemplate中回调的实现，Command就是StatementCallback，里面的doInStatement就是命令方法。CommandImpl就是QueryStatementCallback ，由命令的具体实现去调用真正的执行方法，真正的执行方法就是stmt的executeQuery()。
    - 注意：Command子类膨胀问题
* 状态模式（State）
    - 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
    - 使用场景：状态管理
    - 说明：spring 状态机
    - 注意：和策略模式的比较
* 策略模式（Strategy）
    - 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户
    - 使用场景：一个系统需要动态地在几种算法中选择一种时
    - 说明：
    - 注意：
* 职责链模式
    - 为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
    - 使用场景：员工审批，过滤器
    - 特点：低耦合，可扩展

* 中介者模式

* 访问者模式

* 解释器模式

* 备忘录模式









